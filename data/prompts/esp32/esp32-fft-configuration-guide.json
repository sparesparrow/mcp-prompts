{
  "id": "esp32-fft-configuration-guide",
  "name": "esp32-fft-configuration-guide",
  "description": "Guide for optimizing FFT configuration on ESP32 for audio beat detection",
  "content": "# ESP32 FFT Configuration Guide for Audio Beat Detection\n\n## Current Configuration\n- Sample Rate: {{sampleRate}} Hz\n- FFT Size: {{fftSize}} points\n- Target BPM Range: {{targetBPMRange}}\n- Constraints: {{constraints}}\n\n## FFT Size Optimization\n\n### Recommended FFT Sizes for ESP32\n- **128 points**: Minimal latency ({{calculateLatency 128 sampleRate}}ms), basic beat detection only\n- **256 points**: Good balance ({{calculateLatency 256 sampleRate}}ms), suitable for most music\n- **512 points**: Better frequency resolution ({{calculateLatency 512 sampleRate}}ms), good for complex rhythms\n- **1024 points**: High resolution ({{calculateLatency 1024 sampleRate}}ms), best for detailed analysis\n\n### Selection Criteria\n{{#if (and (gte sampleRate 22050) (lte (index targetBPMRange 0) 100))}}\n**Recommendation**: FFT_SIZE_512 - Good balance for typical music BPM ranges\n{{/if}}\n{{#if (and (gte sampleRate 44100) (gte (index targetBPMRange 0) 150))}}\n**Recommendation**: FFT_SIZE_1024 - Higher resolution needed for fast tempos\n{{/if}}\n{{#if (lt sampleRate 16000)}}\n**Recommendation**: FFT_SIZE_256 - Limited by sample rate\n{{/if}}\n\n## Memory Constraints Analysis\n\n### ESP32 Memory Limits\n- **IRAM**: 256KB total, critical for real-time processing\n- **DRAM**: 320KB, used for data buffers\n- **PSRAM**: Available on some variants (ESP32-WROVER)\n\n### Memory Usage Estimation\n```c\n// For FFT_SIZE_512, complex FFT:\nconst int FFT_SIZE = 512;\nconst int MEMORY_PER_FFT = FFT_SIZE * sizeof(float) * 2;  // Real + Imaginary\n// â‰ˆ 4KB per FFT buffer\n// Need at least 3 buffers: input, output, window\n// Total: ~12KB minimum\n```\n\n## Latency Considerations\n\n### Target Latency Requirements\n- **Real-time beat detection**: <50ms total latency\n- **Interactive applications**: <100ms acceptable\n- **Analysis/offline**: Higher latency acceptable\n\n### Latency Breakdown\n1. **ADC sampling**: 1-5ms depending on configuration\n2. **FFT computation**: {{calculateFFTTime fftSize}}ms on ESP32\n3. **Beat detection algorithm**: 1-10ms\n4. **Output processing**: 1-5ms\n\n**Total estimated latency**: {{calculateTotalLatency sampleRate fftSize}}ms\n\n## Window Function Selection\n\n### Recommended Windows for Beat Detection\n- **Hanning/Hamming**: Good balance of main lobe width and sidelobe suppression\n- **Blackman**: Better sidelobe suppression, slightly wider main lobe\n- **Rectangular**: Simplest, but higher sidelobes (not recommended for music)\n\n### ESP32-Specific Considerations\n- Pre-compute window coefficients to save processing time\n- Use lookup tables for trigonometric functions if possible\n- Consider fixed-point arithmetic for memory-constrained applications\n\n## Hardware Acceleration\n\n### ESP32 FFT Hardware\n- **Not available**: ESP32 doesn't have dedicated FFT hardware\n- **Optimization strategies**:\n  - Use CMSIS-DSP library for optimized implementations\n  - Consider fixed-point FFT for memory savings\n  - Pipeline processing to overlap I/O and computation\n\n### CPU Core Utilization\n- **Dual core**: Use core 1 for audio processing, core 0 for other tasks\n- **Task priorities**: Set audio processing to high priority\n- **Watchdog considerations**: Ensure regular task yielding\n\n## Sample Rate Optimization\n\n### Common Sample Rates\n- **8000 Hz**: Minimal bandwidth, basic beat detection\n- **16000 Hz**: Good for voice/music, adequate for most BPM detection\n- **22050 Hz**: CD quality, excellent frequency resolution\n- **44100 Hz**: Overkill for beat detection, high computational cost\n\n### ESP32 ADC Limitations\n- **Maximum rate**: ~200kHz theoretical, ~100kHz practical\n- **Resolution**: 12-bit ADC\n- **Noise**: Consider oversampling for better SNR\n\n## Beat Detection Algorithm Tuning\n\n### Spectral Flux Method\n```c\n// Recommended parameters for ESP32:\nconst float THRESHOLD = 1.2f;  // Adjust based on audio characteristics\nconst int HISTORY_SIZE = 43;  // ~1 second at 43Hz update rate\nconst float DECAY_RATE = 0.95f; // Spectral flux decay\n```\n\n### Frequency Band Selection\n- **Sub-bass (20-60Hz)**: Fundamental beat information\n- **Bass (60-120Hz)**: Primary beat reinforcement\n- **Mid-range (120-500Hz)**: Additional rhythmic information\n\n### BPM Range Filtering\n- **Slow music (60-100 BPM)**: Emphasize lower frequencies\n- **Fast music (140-200 BPM)**: Include higher harmonics\n- **Variable tempo**: Use adaptive filtering\n\n## Performance Monitoring\n\n### Key Metrics to Track\n1. **CPU usage**: Should not exceed 70% for sustained operation\n2. **Memory usage**: Monitor heap fragmentation\n3. **Latency jitter**: Ensure consistent timing\n4. **Detection accuracy**: Compare against reference implementations\n\n### Optimization Strategies\n- **Buffer management**: Use ping-pong buffers to avoid memory allocation\n- **Algorithm simplification**: Consider simpler beat detection for resource-constrained scenarios\n- **Sampling optimization**: Reduce sample rate during quiet periods\n- **Power management**: Adjust CPU frequency based on audio complexity\n\n## Common Issues and Solutions\n\n### High CPU Usage\n- **Cause**: FFT_SIZE too large or sample rate too high\n- **Solution**: Reduce FFT_SIZE or implement decimation\n\n### Memory Fragmentation\n- **Cause**: Frequent memory allocations\n- **Solution**: Pre-allocate buffers and reuse them\n\n### Inconsistent Detection\n- **Cause**: Poor window function or inadequate preprocessing\n- **Solution**: Implement proper windowing and DC removal\n\n### ADC Noise\n- **Cause**: Poor analog front-end or insufficient filtering\n- **Solution**: Add analog filtering or implement digital noise reduction",
  "isTemplate": true,
  "variables": ["sampleRate", "fftSize", "targetBPMRange", "constraints"],
  "tags": ["esp32", "fft", "audio", "beat-detection", "optimization", "embedded"],
  "category": "esp32",
  "version": 1,
  "createdAt": "2025-01-01T00:00:00.000Z",
  "updatedAt": "2025-01-01T00:00:00.000Z"
}