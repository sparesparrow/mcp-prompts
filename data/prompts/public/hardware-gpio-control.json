{
  "id": "hardware-gpio-control",
  "name": "GPIO Control Pattern",
  "description": "Structured approach for controlling GPIO pins on Raspberry Pi through MIA hardware MCP tools",
  "content": "# GPIO Control Pattern\n\nWhen controlling GPIO pins on Raspberry Pi through MIA hardware:\n\n## Control Sequence\n\n1. **Check pin availability**: Verify the target pin is available and not in use by other systems\n   ```\n   # Use set_gpio_pin with mode check\n   result = set_gpio_pin(pin={{pin_number}}, state=false, mode=\"INPUT\")\n   if result.success:\n       print(f\"Pin {{pin_number}} is available\")\n   ```\n\n2. **Set pin mode**: Configure the pin for INPUT or OUTPUT operation\n   ```\n   # Set pin mode before use\n   result = set_gpio_pin(pin={{pin_number}}, state=false, mode=\"{{gpio_mode}}\")\n   ```\n\n3. **Apply state**: Set the desired HIGH/LOW state for output pins\n   ```\n   # Apply the desired state\n   result = set_gpio_pin(pin={{pin_number}}, state={{gpio_state}}, mode=\"OUTPUT\")\n   ```\n\n4. **Verify state**: Read back the pin state to confirm operation\n   ```\n   # Verify the pin state (using input mode to read)\n   result = set_gpio_pin(pin={{pin_number}}, state=false, mode=\"INPUT\")\n   if result.state == {{expected_state}}:\n       print(\"GPIO operation successful\")\n   ```\n\n## Common GPIO Patterns\n\n### LED Control\n```python\n# Turn LED on\nset_gpio_pin(pin=18, state=true, mode=\"OUTPUT\")\n\n# Turn LED off\nset_gpio_pin(pin=18, state=false, mode=\"OUTPUT\")\n```\n\n### Button Reading\n```python\n# Read button state\nresult = set_gpio_pin(pin=23, state=false, mode=\"INPUT_PULLUP\")\nbutton_pressed = not result.state\n```\n\n### PWM-like Control\n```python\n# Rapid switching for PWM effect\nimport asyncio\n\nasync def pwm_control(pin, frequency, duty_cycle):\n    period = 1.0 / frequency\n    on_time = period * duty_cycle\n    off_time = period - on_time\n    \n    while True:\n        set_gpio_pin(pin=pin, state=true, mode=\"OUTPUT\")\n        await asyncio.sleep(on_time)\n        set_gpio_pin(pin=pin, state=false, mode=\"OUTPUT\")\n        await asyncio.sleep(off_time)\n```\n\n## Safety Considerations\n\n- Always set pin mode before use\n- Use INPUT_PULLUP for buttons to avoid floating states\n- Verify pin operations with read-back\n- Handle MCP tool errors gracefully\n- Consider power requirements for connected devices\n\n## Error Handling\n\n```python\ntry:\n    result = set_gpio_pin(pin={{pin_number}}, state={{gpio_state}}, mode=\"{{gpio_mode}}\")\n    if not result.success:\n        print(f\"GPIO error: {result.error_message}\")\n        # Implement fallback logic\nexcept Exception as e:\n    print(f\"MCP tool error: {e}\")\n    # Implement error recovery\n```\n\n## Hardware-Specific Notes\n\n- GPIO pins 0-27 are available on most Raspberry Pi models\n- Some pins have special functions (I2C, SPI, UART)\n- Always check pinout diagrams for your specific Pi model\n- Consider using pin libraries for complex operations\n\nUse this pattern to ensure reliable GPIO control through the MIA hardware MCP interface.",
  "variables": [
    "pin_number",
    "gpio_mode",
    "gpio_state",
    "expected_state"
  ],
  "tags": ["hardware", "gpio", "raspberry-pi", "mcp", "mia"],
  "author": "MIA System",
  "version": "2.0.0"
}