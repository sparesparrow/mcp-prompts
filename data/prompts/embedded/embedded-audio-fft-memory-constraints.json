{
  "id": "embedded-audio-fft-memory-constraints",
  "name": "Embedded Audio FFT Memory Constraints",
  "description": "Optimize FFT processing on ESP32 with 320KB RAM for real-time audio analysis",
  "content": "# Embedded Audio FFT Memory Constraints\n\n## Problem\nFFT processing on ESP32 with 320KB RAM requires careful memory management to avoid crashes and maintain real-time performance for audio beat detection.\n\n## Memory Constraints\n\n### ESP32-S3 Memory Layout\n```\nTotal RAM: 320KB\n├── System/FreeRTOS: ~40KB\n├── WiFi Stack: ~30KB (AP mode: +40KB)\n├── HTTP Server: ~15KB\n├── Application Code: ~50KB\n└── Available for Data: ~185KB (STA) or ~145KB (AP)\n```\n\n### FFT Buffer Requirements\n```cpp\n// For FFT_SIZE_512, complex FFT:\nconst int FFT_SIZE = 512;\nconst int MEMORY_PER_FFT = FFT_SIZE * sizeof(float) * 2;  // Real + Imaginary\n// ≈ 4KB per FFT buffer\n\n// Need at least 3 buffers:\n// - Input buffer: 4KB\n// - Output buffer: 4KB  \n// - Window coefficients: 4KB\n// Total: ~12KB minimum\n\n// With overlap and history:\n// - Input buffer: 4KB\n// - FFT output: 4KB\n// - Window: 4KB\n// - Envelope history: 2KB\n// - Beat detection history: 1KB\n// Total: ~15KB for complete pipeline\n```\n\n## Optimization Strategies\n\n### 1. Use Float32 (Not Double)\n```cpp\n// ❌ Bad: Uses 8 bytes per sample\nfloat64_t samples[FFT_SIZE];\n\n// ✅ Good: Uses 4 bytes per sample\nfloat samples[FFT_SIZE];\n\n// Memory savings: 50% (4KB vs 8KB for 512 samples)\n```\n\n### 2. Pre-allocate Buffers at Startup\n```cpp\n// ✅ Good: Allocate once, reuse forever\nclass BPMDetector {\nprivate:\n    float* fftInput;      // Pre-allocated\n    float* fftOutput;     // Pre-allocated\n    float* windowCoeffs; // Pre-allocated\n    \npublic:\n    BPMDetector() {\n        // Allocate at construction time\n        fftInput = (float*)malloc(FFT_SIZE * sizeof(float));\n        fftOutput = (float*)malloc(FFT_SIZE * sizeof(float));\n        windowCoeffs = (float*)malloc(FFT_SIZE * sizeof(float));\n        \n        // Pre-compute window coefficients\n        for (int i = 0; i < FFT_SIZE; i++) {\n            windowCoeffs[i] = 0.5f * (1.0f - cosf(2.0f * PI * i / FFT_SIZE));\n        }\n    }\n    \n    ~BPMDetector() {\n        free(fftInput);\n        free(fftOutput);\n        free(windowCoeffs);\n    }\n};\n\n// ❌ Bad: Allocating in processing loop\nvoid processAudio() {\n    float* buffer = (float*)malloc(FFT_SIZE * sizeof(float)); // Memory leak!\n    // ... process ...\n    // Forgot to free() - memory leak on every call\n}\n```\n\n### 3. Use Power-of-2 FFT Sizes\n```cpp\n// ✅ Good: Hardware-optimized sizes\nconst int FFT_SIZE = 512;   // 2^9\nconst int FFT_SIZE = 256;   // 2^8\nconst int FFT_SIZE = 1024;  // 2^10\n\n// ❌ Bad: Non-power-of-2 requires more computation\nconst int FFT_SIZE = 500;  // Slower, more memory\n```\n\n### 4. Monitor Heap Usage\n```cpp\nvoid processAudio() {\n    unsigned long heapBefore = ESP.getFreeHeap();\n    \n    // ... FFT processing ...\n    \n    unsigned long heapAfter = ESP.getFreeHeap();\n    \n    if (heapAfter < 50000) {  // Less than 50KB free\n        Serial.println(\"WARNING: Low memory!\");\n    }\n    \n    // Log memory usage periodically\n    static unsigned long lastLog = 0;\n    if (millis() - lastLog > 5000) {\n        Serial.printf(\"Free heap: %lu bytes\\n\", heapAfter);\n        lastLog = millis();\n    }\n}\n```\n\n### 5. Minimize Temporary Allocations\n```cpp\n// ❌ Bad: Creates temporary objects\nString json = \"{\";\njson += \"\\\"bpm\\\":\" + String(bpm, 1);\njson += \"}\";\n// Each String operation may allocate memory\n\n// ✅ Good: Use fixed buffer\nchar json[128];\nsnprintf(json, sizeof(json), \"{\\\"bpm\\\":%.1f}\", bpm);\n// No dynamic allocation\n```\n\n## Memory Usage Patterns\n\n### Typical Memory Footprint\n```\nApplication Startup:\n├── FreeRTOS: 40KB\n├── WiFi (AP mode): 70KB\n├── HTTP Server: 15KB\n├── FFT Buffers: 15KB\n├── Audio Input Buffer: 8KB\n├── BPM Detection State: 2KB\n└── Application Code: 50KB\n─────────────────────────────\nTotal Used: ~200KB\nFree Heap: ~120KB (safe margin)\n```\n\n### Memory Fragmentation Prevention\n```cpp\n// ✅ Good: Allocate large blocks early\nvoid setup() {\n    // Allocate all buffers at startup\n    // This creates contiguous memory blocks\n    initFFTBuffers();\n    initAudioBuffers();\n    initNetworkBuffers();\n    \n    // Now memory is stable\n    Serial.printf(\"Initial free heap: %lu\\n\", ESP.getFreeHeap());\n}\n\n// ❌ Bad: Allocating/deallocating in loop\nvoid loop() {\n    float* temp = malloc(1024);  // Fragments memory\n    // ... use ...\n    free(temp);  // Leaves holes\n}\n```\n\n## FFT Size Selection Guide\n\n### Memory vs Performance Trade-offs\n\n| FFT Size | Memory (KB) | Latency (ms @ 25kHz) | Frequency Resolution (Hz) | Use Case |\n|----------|-------------|----------------------|---------------------------|----------|\n| 128      | 1           | 5                    | 195                       | Minimal latency, basic detection |\n| 256      | 2           | 10                   | 98                        | Good balance, most music |\n| 512      | 4           | 20                   | 49                        | Better resolution, complex rhythms |\n| 1024     | 8           | 41                   | 24                        | High resolution, detailed analysis |\n\n### Selection Criteria\n```cpp\n// Choose FFT size based on requirements\n#if SAMPLE_RATE >= 22050 && TARGET_BPM_MIN <= 100\n    #define FFT_SIZE 512  // Good balance\n#elif SAMPLE_RATE >= 44100 && TARGET_BPM_MIN >= 150\n    #define FFT_SIZE 1024  // Higher resolution for fast tempos\n#elif SAMPLE_RATE < 16000\n    #define FFT_SIZE 256   // Limited by sample rate\n#endif\n```\n\n## Monitoring and Debugging\n\n### Heap Monitoring Code\n```cpp\nvoid printMemoryStats() {\n    Serial.println(\"=== Memory Statistics ===\");\n    Serial.printf(\"Free heap: %lu bytes\\n\", ESP.getFreeHeap());\n    Serial.printf(\"Largest free block: %lu bytes\\n\", ESP.getMaxAllocHeap());\n    Serial.printf(\"Min free heap (ever): %lu bytes\\n\", ESP.getMinFreeHeap());\n    Serial.printf(\"Heap fragmentation: %.1f%%\\n\", \n        100.0f * (1.0f - (float)ESP.getMaxAllocHeap() / ESP.getFreeHeap()));\n}\n\n// Call periodically\nif (millis() % 10000 == 0) {\n    printMemoryStats();\n}\n```\n\n### Memory Leak Detection\n```cpp\n// Track allocations\nstatic unsigned long initialHeap = 0;\n\nvoid setup() {\n    initialHeap = ESP.getFreeHeap();\n    Serial.printf(\"Initial heap: %lu\\n\", initialHeap);\n}\n\nvoid loop() {\n    unsigned long currentHeap = ESP.getFreeHeap();\n    \n    // Check for memory leaks (heap decreasing over time)\n    if (currentHeap < initialHeap - 10000) {  // Lost > 10KB\n        Serial.printf(\"WARNING: Possible memory leak!\\n\");\n        Serial.printf(\"Initial: %lu, Current: %lu, Lost: %lu\\n\",\n            initialHeap, currentHeap, initialHeap - currentHeap);\n    }\n}\n```\n\n## Best Practices Summary\n\n1. **Pre-allocate all buffers** at startup\n2. **Use float32** (not double) for FFT\n3. **Power-of-2 FFT sizes** for efficiency\n4. **Monitor heap** with ESP.getFreeHeap()\n5. **Avoid dynamic allocation** in processing loops\n6. **Keep free heap > 50KB** for stability\n7. **Use fixed-size buffers** instead of String/Vector\n8. **Allocate large blocks early** to prevent fragmentation\n\n## Related Patterns\n\n- Use with `esp32-network-ap-mode-configuration` (AP mode uses +40KB)\n- Combine with `esp32-mcp-server-http-api-integration` (HTTP server uses ~15KB)\n- See `esp32-platformio-serial-upload-debugging` for build optimization\n\n## Success Metrics\n\n- **Free Heap**: Stays > 50KB during operation\n- **Memory Stability**: No heap fragmentation over 24 hours\n- **FFT Latency**: < 50ms for real-time processing\n- **Crash Rate**: Zero crashes due to memory issues",
  "isTemplate": false,
  "tags": ["embedded", "esp32", "audio", "memory", "fft", "optimization", "real-time"],
  "category": "embedded",
  "version": 1,
  "createdAt": "2026-01-01T03:00:00.000Z",
  "updatedAt": "2026-01-01T03:00:00.000Z",
  "metadata": {
    "context": ["embedded", "esp32", "audio", "memory", "real-time"],
    "problem": "FFT processing on ESP32 with 320KB RAM: optimize memory usage",
    "success_count": 1,
    "confidence": "medium",
    "constraints": {
      "total_ram": "320KB",
      "available_after_system": "~200KB",
      "fft_buffer_size_samples": 512,
      "fft_buffer_bytes": "512 * 4 bytes float = 2KB"
    },
    "related_prompts": [
      "esp32-mcp-server-http-api-integration",
      "esp32-network-ap-mode-configuration"
    ]
  }
}