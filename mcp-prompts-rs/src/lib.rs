use binder::{
    Interface, Result, Strong,
    sys::{AIBinder, SpIBinder},
    StatusCode,
};
use std::ffi::c_void;
use serde::Deserialize;
use async_trait::async_trait;

#[derive(Debug, Deserialize, Clone)]
pub struct Prompt {
    pub id: String,
    pub name: String,
    pub content: String,
    pub tags: Option<Vec<String>>,
}

// This would be generated by the AIDL compiler (e.g., rsbinder-aidl or the AOSP build system)
// We are defining a minimal version here for demonstration purposes.
mod com {
    pub mod sparesparrow {
        pub mod mcp {
            use binder::{
                declare_binder_interface,
                Interface, Result, StatusCode, Strong,
                parcel::Parcel,
            };

            declare_binder_interface! {
                IMcpService["com.sparesparrow.mcp.IMcpService"] {
                    native: BnMcpService,
                    proxy: BpMcpService,
                    async: on_transact, // This enables async methods
                }
            }

            #[async_trait]
            impl IMcpService for BpMcpService {
                async fn getPrompt(&self, id: &str) -> Result<String> {
                    unimplemented!()
                }
                async fn applyTemplate(&self, id: &str, jsonVariables: &str) -> Result<String> {
                    unimplemented!()
                }
                async fn listPrompts(&self) -> Result<String> {
                    unimplemented!()
                }
                async fn setApiKey(&self, apiKey: &str) -> Result<()> {
                    unimplemented!()
                }
            }
        }
    }
}

use com::sparesparrow::mcp::{BnMcpService, IMcpService};

#[derive(Debug)]
pub struct McpApiClient {
    base_url: String,
    client: reqwest::Client,
}

impl McpApiClient {
    pub fn new(base_url: &str) -> Self {
        Self {
            base_url: base_url.to_string(),
            client: reqwest::Client::new(),
        }
    }

    pub async fn list_prompts(&self, apiKey: &str) -> anyhow::Result<Vec<Prompt>> {
        let url = format!("{}/prompts", self.base_url);
        let prompts = self.client.get(&url)
            .header("x-api-key", apiKey)
            .send()
            .await?
            .json::<Vec<Prompt>>()
            .await?;
        Ok(prompts)
    }

    pub async fn get_prompt(&self, id: &str, apiKey: &str) -> anyhow::Result<Prompt> {
        let url = format!("{}/prompts/{}", self.base_url, id);
        let prompt = self.client.get(&url)
            .header("x-api-key", apiKey)
            .send()
            .await?
            .json::<Prompt>()
            .await?;
        Ok(prompt)
    }
}

#[derive(Debug, Default)]
pub struct McpNativeService {
    client: McpApiClient,
    api_key: std::sync::RwLock<Option<String>>,
}

impl McpNativeService {
    pub fn new() -> Self {
        Self {
            client: McpApiClient::new("http://10.0.2.2:3003"),
            api_key: std::sync::RwLock::new(None),
        }
    }
}

impl Interface for McpNativeService {}

#[async_trait]
impl IMcpService for McpNativeService {
    async fn getPrompt(&self, id: &str) -> Result<String> {
        let key_guard = self.api_key.read().unwrap();
        let key = key_guard.as_deref().unwrap_or_default();
        match self.client.get_prompt(id, key).await {
            Ok(prompt) => Ok(serde_json::to_string(&prompt).unwrap_or_default()),
            Err(_) => Err(StatusCode::UNKNOWN_ERROR.into()),
        }
    }

    async fn applyTemplate(&self, id: &str, json_variables: &str) -> Result<String> {
        Ok(format!("{{\"rendered\":\"Native template '{}' with variables '{}'\"}}", id, json_variables))
    }

    async fn listPrompts(&self) -> Result<String> {
        let key_guard = self.api_key.read().unwrap();
        let key = key_guard.as_deref().unwrap_or_default();
        match self.client.list_prompts(key).await {
            Ok(prompts) => Ok(serde_json::to_string(&prompts).unwrap_or_default()),
            Err(_) => Err(StatusCode::UNKNOWN_ERROR.into()),
        }
    }

    async fn setApiKey(&self, apiKey: &str) -> Result<()> {
        let mut key_guard = self.api_key.write().unwrap();
        *key_guard = Some(apiKey.to_string());
        Ok(())
    }
}

#[no_mangle]
pub extern "C" fn init_tokio_runtime() {
    // This should only be called once when the service is created.
    tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()
        .unwrap()
        .enter();
}

#[no_mangle]
pub extern "C" fn make_mcp_service() -> *mut c_void {
    let service = McpNativeService::new();
    let binder = BnMcpService::new_binder(service, binder::BinderFeatures::default());
    // Leaking the binder object to be owned by the caller (the Android service)
    Box::into_raw(Box::new(binder.as_binder())) as *mut c_void
}

#[no_mangle]
pub unsafe extern "C" fn destroy_service(service: *mut c_void) {
    if !service.is_null() {
        // This will reclaim the memory for the Box<SpIBinder>
        let _ = Box::from_raw(service as *mut SpIBinder);
    }
} 